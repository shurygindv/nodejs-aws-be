// import { PoolClient } from 'pg';
import * as jestPlugin from "serverless-jest-plugin";

import * as mod from "./../handler";
// tests for getAllProducts
// Generated by serverless-jest-plugin

const lambdaWrapper = jestPlugin.lambdaWrapper;
const wrapped = lambdaWrapper.wrap(mod, { handler: "getAllProducts" });

type Response = {
  statusCode: number;
  body: string;
};

const pgClient = {
  // @ts-ignore
  query: jest.fn(() =>
    Promise.resolve({
      rows: [],
    })
  ),
  release: jest.fn(),
};

jest.mock("pg", () => ({
  Pool: jest.fn(() => ({
    connect: jest.fn(() => Promise.resolve(pgClient)),
  })),
}));

describe("getAllProducts", () => {
  beforeAll((done) => {
    done();
  });

  it("implement tests here", () => {
    return wrapped.run({}).then((response: Response) => {
      expect(response).toBeDefined();
    });
  });

  it("should contain body", () => {
    return wrapped.run({}).then((response: Response) => {
      expect(response.body).toBeDefined();
    });
  });

  it("should contain body result", () => {
    return wrapped.run({}).then((response: Response) => {
      const body = JSON.parse(response.body);

      expect(body).toBeDefined();
    });
  });

  it("should contain success code", () => {
    return wrapped.run({}).then((response: Response) => {
      expect(response.statusCode).toEqual(200);
    });
  });

  it("PG: should release connection once", async () => {
    await pgClient.release.mockClear();

    return wrapped.run({}).then(() => {
      expect(pgClient.release).toHaveBeenCalledTimes(1);
    });
  });

  it("PG: should query PG once", async () => {
    await pgClient.query.mockClear();


    return wrapped.run({}).then(() => {
      expect(pgClient.query).toHaveBeenCalledTimes(1);
    });
  });
});
